import socks
import socket
import argparse
import os
import sys
import subprocess
from duduIP import 
from parse_proxychains import ParseProxy

class Duduzovisk:
	def set_args(self):
		parser = argparse.ArgumentParser(description="««GET INFO BY URL»»")
		parser.add_argument('-t','--target',help="spicify url target")
		parser.add_argument('-f','--file',help='spicify file of urls targets')
		parser.add_argument('-i','--intercept',help='enable the intercept data',action='store_true')
		parser.add_argument('-l','--localization',help='enable geolocalization',action='store_true')
		parser.add_argument('-p','--proxy',help='enable proxy in code',action='store_true')
		parser.add_argument('-v','--verbose',help='enable the verbose mode',action='store_true')
		parser.add_argument('-Pt','--parse_traffic',help='enable parsing the file traffic',action='store_true')
		parser.add_argument('-o', '--orgs', help="active the verbose mode", action='store_true')
		args = parser.parse_args()
		self.target = args.target
		self.file = args.file
		self.intercept = args.intercept
		self.localization = args.localization
		self.proxy = args.proxy
		self.verbose = args.verbose
		self.parse_traffic = args.parse_traffic
		self.proxy_log = ''
		return args

	def get_domain(self,url):
		if url != None:
			try:
				domain = url.split("https://")[1]
				domain.split('/')[0]
				return domain
			except:
				try:
					domain = url.split("http://")[1]
					domain = domain.split('/')[0]
				except:
					print(url)
				return domain
		else:
			print('url sem http:// ou https://')
			return domain

	def parser_traffic(self):
		dominio = self.get_domain(self.target)
		log = f'/home/dragon/pentest/Script/webScraping/buffer_of_intercept/{dominio}.txt'
		moz_log_file = f'--MOZ_LOG_FILE={log}'
		if self.proxy:
			self.proxy_log = f'{log}.log'
			with open(self.proxy_log,'w') as file:
				cmd = ['proxychains','firefox',self.target,'--MOZ_LOG=nsHttp:5',moz_log_file]
				logs = subprocess.Popen(cmd,stdout=subprocess.PIPE,stderr=subprocess.STDOUT,text=True)
				ips = []
				for line in logs.stdout:
					file.write(line)
				logs.wait()
			with open(self.proxy_log,'r') as file:
				proxylog = file.read()
			listLog = proxylog.split('\n')
			countIp=0
			for i, line in enumerate(listLog):
				try:
					rest = line.split('-<><>-')[1]
					ip = rest.split('-')[0]
					if ip not in ips:
						ips.append(ip)
						countIp+=1
				except:
					dns = line.split(' ')
					if 'is' in dns:
						ip = line.split('is ')[1]
						if ip not in ips:
							ips.append(ip)
							countIp+=1
			with open(self.proxy_log,'w') as file:
				proxy_lista=''
				for ip in ips:
					proxy_lista+=f'{ip}\n'
				file.write(proxy_lista)
				print(proxy_lista)
			return proxy_lista
		else:
			log = f'/home/dragon/pentest/Script/webScraping/buffer_of_intercept/urlInfo_intercept'
			self.proxy_log = f'{log}.log'
			subprocess.run(['firefox',self.target,'--MOZ_LOG=nsHttp:5',moz_log_file])
			with open(self.proxy_log,'w') as file:
					cmd = ['proxychains','firefox',self.target,'--MOZ_LOG=nsHttp:5',moz_log_file]
					logs = subprocess.Popen(cmd,stdout=subprocess.PIPE,stderr=subprocess.STDOUT,text=True)
					ips = []
					for line in logs.stdout:
						file.write(line)
					logs.wait()
			with open(self.proxy_log,'r') as file:
				proxylog = file.read()
			listLog = proxylog.split('\n')
			countIp=0
			for i, line in enumerate(listLog):
				try:
					rest = line.split('-<><>-')[1]
					ip = rest.split('-')[0]
					if ip not in ips:
						ips.append(ip)
						countIp+=1
				except:
					dns = line.split(' ')
					if 'is' in dns:
						ip = line.split('is ')[1]
						if ip not in ips:
							ips.append(ip)
							countIp+=1
			with open(self.proxy_log,'w') as file:
				proxy_lista=''
				for ip in ips:
					proxy_lista+=f'{ip}\n'
				file.write(proxy_lista)
				print(proxy_lista)
			return proxy_lista

			return None

	def set_to_list(self,ipv):
		ipv = str(ipv)
		ipv = ipv.replace("{","")
		ipv = ipv.replace("}","")
		ipv = ipv.replace("'","")
		if "," in ipv:
			ipv = ipv.split(", ")
		return ipv

	def proxychains_parse(self,url):
		listUrl = url.split('-<>-')
		action = listUrl[0]
		ips = listUrl[1]
		return action, ips

	def obter_ips(self,url):
		try:
			ipv4_enderecos = socket.getaddrinfo(url, None, socket.AF_INET)
			try:
				ipv6_enderecos = socket.getaddrinfo(url, None, socket.AF_INET6)
			except:
				ipv4_enderecos = [info[4][0] for info in ipv4_enderecos]
				return set(ipv4_enderecos), None

			ipv4_enderecos = [info[4][0] for info in ipv4_enderecos]
			ipv6_enderecos = [info[4][0] for info in ipv6_enderecos]
			return set(ipv4_enderecos), set(ipv6_enderecos)
		except Exception as erro:
			print(f'erro in obter_ips() {erro}')
			return None, None

	def main(self):
		args = self.set_args()
		if args.target:
			verify = args.target.split("://")
			if verify[0] == 'https' or verify[0] == 'http':
				dominio = verify[1]
			else:
				dominio = args.target
			ipv4, ipv6 = self.obter_ips(dominio)
			try:
				ipv4 = set_to_list(ipv4)
			except Exception as erro:
				print(f'conversion error in set_to_list(): {erro} [ipv4]')

			try:
				if ipv6 != None:
					ipv6 = set_to_list(ipv6)
			except Exception as erro:
				print(f'conversion error in set_to_list(): {erro} [ipv6] {ipv6}')

			print(f"IPv4: {ipv4}")
			print(f"IPv6: {ipv6}")

			if args.localization:
				try:
					dip = DuduIP()
					if type(ipv4) == str:
						info = dip.info_of_ip(ipv4)
						print(info)
					elif type(ipv4) == list:
						for ipv in ipv4:
							info = dip.info_of_ip(ipv)
							print(info)
				except subprocess.CalledProcessError as error:
					print(f'erro in geolocalization: {error}')

			if args.intercept:
				if ipv4 is None:
					traffic = self.parser_traffic()
					print(traffic)

		if args.file:
			arquivo=''
			found_domains=[]
			with open(args.file,'r') as file:
					for char in file.read():
						if char:
							arquivo+=char
			urls = arquivo.split('\n')
			log=f'data_of_url.log'
			with open(log,'w') as file:
				for url in urls:
					if url == "":
						continue
					dominio, _ = self.get_domain(url)
					try:
						dominio = None
						dominio, _ = self.get_domain(url)
					except Exception as erro:
						print(f'erro no get_domain(): {erro}')
						continue

					if dominio in found_domains:
						continue

					ipv4, ipv6 = self.obter_ips(dominio)
					try:
						ipv4 = self.set_to_list(ipv4)
					except Exception as erro:
						print(f"erro no set_to_list(): {erro} [ipv4]")

					if ipv6 is not None:
						try:
							ipv6 = self.set_to_list(ipv6)
						except Exception as erro:
							print(f'erro no set_to_list(): {erro} [ipv6]')

					found_domains.append(dominio)
					file.write(f"Domain: {dominio}\n")
					file.write(f"IPv4: {ipv4}\n")
					file.write(f"IPv6: {ipv6}\n")

					if args.verbose:
						print(f'domanin:\t{url}')
						print(f'ipv4:\t{ipv4}')
						print(f'ipv6:\t{ipv6}')

					if args.localization:
						for ip in ipv4:
							try:
								dip = DuduIP()
								info = dip.info_of_ip(ip)
								if info['status'] == 'success':
									print(f'{info}\n')
							except Exception as error:
								print(f'erro in geolocalization: {error}')


		return
if __name__ == '__main__':
	dudu = Duduzovisk()
	dudu.main()

